#!/bin/bash
# Script de test unifié pour letmein
# Ce script remplace les scripts séparés (run-tests.sh, docker-test.sh, debug-test.sh)
# Il est utilisé pour exécuter les tests localement, dans Docker, ou en mode débogage

# Couleurs pour la lisibilité
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Répertoire de logs par défaut
LOG_DIR="$(pwd)/nft-logs"

# Variables par défaut
MODE="local"
WITH_GEN_KEY=0
LOG_LEVEL="normal"
CAPTURE_INTERVAL=5
RUN_TESTS=()

# Afficher l'aide
show_help() {
    echo -e "${GREEN}===== LETMEIN UNIFIED TEST SCRIPT =====${NC}"
    echo -e "Usage: $0 [OPTIONS] [TESTS]"
    echo -e "${BLUE}Modes:${NC}"
    echo -e "  --local              Run tests locally (default)"
    echo -e "  --docker             Run tests in Docker container"
    echo -e "  --debug              Start interactive debugging shell in Docker"
    echo -e "\n${BLUE}Test Options:${NC}"
    echo -e "  # Option --real retirée car on utilise toujours les vrais nftables maintenant"
    echo -e "  --with-gen-key       Include gen-key test (disabled by default)"
    echo -e "  --capture-interval N Set interval between state captures (seconds, default: $CAPTURE_INTERVAL)"
    echo -e "  --verbose            Enable verbose logging"
    echo -e "  --minimal            Minimal logging output"
    echo -e "\n${BLUE}Available Tests:${NC}"
    echo -e "  knock                Run knock tests"
    echo -e "  close                Run close tests"
    echo -e "  gen-key              Run gen-key test (requires --with-gen-key)"
    echo -e "\n${BLUE}Examples:${NC}"
    echo -e "  $0 knock close       Run knock and close tests locally with mock nftables"
    echo -e "  $0 --docker --real   Run all tests in Docker with real nftables"
    echo -e "  $0 --debug           Start debugging shell in Docker"
    echo -e "  $0 --with-gen-key gen-key  Run gen-key test locally"
    echo -e "\n${YELLOW}Note:${NC} If no test is specified, all appropriate tests will run"
    echo -e "      (knock and close by default, plus gen-key if --with-gen-key is used)"
    exit 0
}

# Function to capture nftables state
capture_nft_state() {
    local state_name="$1"
    local timestamp="$(date +%Y%m%d-%H%M%S)"
    mkdir -p "$LOG_DIR"
    local state_file="$LOG_DIR/nft-state-$state_name-$timestamp.log"
    
    echo -e "${BLUE}Capturing nftables state: $state_name...${NC}"
    
    echo "== nftables state: $state_name ==" > "$state_file"
    echo "Timestamp: $(date)" >> "$state_file"
    echo "== Command: nft list ruleset ==" >> "$state_file"
    
    if [ "$MODE" = "docker" ]; then
        # Dans Docker nous avons probablement des droits suffisants
        echo "Exécution de 'nft list ruleset' dans Docker..." >> "$state_file"
        nft list ruleset >> "$state_file" 2>&1
        if [ $? -ne 0 ]; then
            echo "Error: nft command failed with exit code $?" >> "$state_file"
            echo "Commande nftables échouée dans Docker" 
        fi
    else
        # En local, nous avons peut-être besoin de sudo
        echo "Exécution de 'sudo nft list ruleset' en local..." >> "$state_file"
        sudo nft list ruleset >> "$state_file" 2>&1 
        if [ $? -ne 0 ]; then
            echo "Error: sudo nft command failed with exit code $?" >> "$state_file"
            echo "Commande sudo nftables échouée en local"
        fi
    fi
}

# Fonction pour afficher les informations sur les logs
display_logs_info() {
    echo -e "${BLUE}=== DEBUG LOGS INFORMATION ===${NC}"
    echo -e "Debug logs are available in: $LOG_DIR"
    
    if [ -d "$LOG_DIR" ]; then
        echo -e "Important log files:"
        ls -la "$LOG_DIR" | grep -v "total" | head -20 | while read line; do
            echo -e "- $LOG_DIR/$(echo "$line" | awk '{print $NF}')"
        done
        
        echo -e "\nCurrent nftables state:"
        if [ "$MODE" = "docker" ]; then
            echo -e "(Run with --debug to inspect current state in container)"
        else
            sudo nft list ruleset | grep -A 3 -B 3 letmein || echo "No letmein rules found"
        fi
        
        echo -e "\nUseful commands:"
        echo -e "- To view test output: less -R $LOG_DIR/nft-state-after-tests-*.log"
        echo -e "- To compare before/after: diff $LOG_DIR/nft-state-before-tests-*.log $LOG_DIR/nft-state-after-tests-*.log"
    else
        echo -e "${YELLOW}Warning: Log directory $LOG_DIR does not exist${NC}"
    fi
}

# Capture périodique en background
start_periodic_capture() {
    if [ "$CAPTURE_INTERVAL" -gt 0 ]; then
        echo -e "${BLUE}Starting periodic nftables state capture (interval: ${CAPTURE_INTERVAL}s)...${NC}"
        
        # Clean any existing capture processes
        pkill -f "nft-periodic-capture" >/dev/null 2>&1 || true
        
        # Start new background process
        (
            while true; do
                capture_nft_state "periodic-$(date +%Y%m%d-%H%M%S)"
                sleep $CAPTURE_INTERVAL
            done
        ) &
        PERIODIC_CAPTURE_PID=$!
        echo -e "${BLUE}Periodic capture started with PID $PERIODIC_CAPTURE_PID${NC}"
    fi
}

# Local test function
run_local_tests() {
    echo -e "${GREEN}=== RUNNING LOCAL TESTS ===${NC}"
    
    # Capture initial state
    capture_nft_state "initial"
    
    # Start periodic capture if in debug mode
    if [ "$LOG_LEVEL" = "verbose" ]; then
        start_periodic_capture
    fi
    
    # Build the project if necessary
    echo -e "${YELLOW}Building the project...${NC}"
    cargo build
    
    # Set environment variables
    export LETMEIN_DISABLE_SECCOMP=1
    # Nous utilisons toujours les vrais nftables maintenant
    unset MOCK_NFTABLES
    
    # Capture state before tests
    capture_nft_state "before-tests"
    
    # Prepare test arguments
    local test_args=""
    if [ ${#RUN_TESTS[@]} -gt 0 ]; then
        test_args="${RUN_TESTS[*]}"
    else
        # Default tests
        if [ "$WITH_GEN_KEY" = "1" ]; then
            test_args="knock close gen-key"
        else
            test_args="knock close"
        fi
    fi
    
    echo -e "${YELLOW}Running tests: $test_args${NC}"
    
    # Run tests with sudo for nftables access
    sudo -E ./tests/run-tests.sh $test_args
    TEST_EXIT_CODE=$?
    
    # Capture state after tests
    capture_nft_state "after-tests"
    
    # Stop periodic capture if running
    if [ -n "$PERIODIC_CAPTURE_PID" ]; then
        kill $PERIODIC_CAPTURE_PID >/dev/null 2>&1 || true
    fi
    
    # Display test results
    if [ $TEST_EXIT_CODE -eq 0 ]; then
        echo -e "${GREEN}=== LOCAL TESTS SUCCEEDED ===${NC}"
    else
        echo -e "${RED}=== LOCAL TESTS FAILED (exit code: $TEST_EXIT_CODE) ===${NC}"
    fi
    
    # Display debug logs information
    display_logs_info
    
    return $TEST_EXIT_CODE
}

# Docker test function
run_docker_tests() {
    echo -e "${GREEN}=== RUNNING DOCKER TESTS ===${NC}"
    
    # Build Docker image
    echo -e "${BLUE}Creating Docker image for tests...${NC}"
    docker build -t letmein-test -f Dockerfile.test . || {
        echo -e "${RED}Failed to build Docker image${NC}"
        return 1
    }
    
    # Prepare test arguments
    local test_args=""
    if [ ${#RUN_TESTS[@]} -gt 0 ]; then
        test_args="${RUN_TESTS[*]}"
    else
        # Default tests
        if [ "$WITH_GEN_KEY" = "1" ]; then
            test_args="knock close gen-key"
        else
            test_args="knock close"
        fi
    fi
    
    # Create log directory
    mkdir -p "$LOG_DIR"
    
    echo -e "${YELLOW}Running tests in Docker: $test_args${NC}"
    echo -e "${YELLOW}Using real nftables for all tests${NC}"
    
    # Créer un script temporaire pour éviter les problèmes d'interprétation
    DOCKER_SCRIPT="$(mktemp)"
    
    # Écrire le script Docker avec une syntaxe claire
    cat > "$DOCKER_SCRIPT" << 'EOF'
#!/bin/sh

# Configuration stricte pour détecter les erreurs
set -e

# Variables passées par l'environnement
LOG_DIR=${LOG_DIR:-/app/nft-logs}
TEST_ARGS=${TEST_ARGS:-knock close}

# --- Création du répertoire de logs ---
mkdir -p "$LOG_DIR"
echo "Répertoire de logs créé: $LOG_DIR"

# --- Capture de l'état initial ---
echo "=== Capture de l'état initial des règles nftables ==="
nft list ruleset > "$LOG_DIR/nft-state-initial-$(date +%Y%m%d-%H%M%S).log"

# --- Compilation si nécessaire ---
echo "=== Compilation du projet ==="
cargo build
BUILD_RESULT=$?

if [ $BUILD_RESULT -ne 0 ]; then
    echo "ERREUR: Échec de la compilation (code: $BUILD_RESULT)"
    exit $BUILD_RESULT
fi

# --- Capture pré-test ---
echo "=== Capture de l'état des règles nftables avant les tests ==="
nft list ruleset > "$LOG_DIR/nft-state-before-tests-$(date +%Y%m%d-%H%M%S).log"

# -- Exécution des tests ---
echo "=== Exécution des tests: $TEST_ARGS ==="
cd ./tests
./run-tests.sh $TEST_ARGS
TEST_RESULT=$?
cd ..

# --- Capture post-test ---
echo "=== Capture de l'état des règles nftables après les tests ==="
nft list ruleset > "$LOG_DIR/nft-state-after-tests-$(date +%Y%m%d-%H%M%S).log"

# --- Affichage du résumé des logs ---
echo "=== Tests terminés avec le code de sortie: $TEST_RESULT ==="
echo "=== Logs nftables générés: ==="
ls -la "$LOG_DIR/"

# Retourne le statut des tests
exit $TEST_RESULT
EOF

    # Rendre le script exécutable
    chmod +x "$DOCKER_SCRIPT"
    
    # --- Exécuter les tests dans Docker avec les vrais nftables ---
    echo -e "${BLUE}Lancement du conteneur Docker pour les tests...${NC}"
    
    # --- Construction explicite de la commande Docker ---
    echo -e "${BLUE}Construction de la commande Docker...${NC}"
    
    # Construction de la commande Docker de manière plus sécurisée
    # en évitant les problèmes d'expansion de variables
    docker run \
        --rm \
        --privileged \
        --cap-add=NET_ADMIN \
        --cap-add=SYS_ADMIN \
        --dns 8.8.8.8 \
        --dns 1.1.1.1 \
        --security-opt seccomp=unconfined \
        -e LETMEIN_DISABLE_SECCOMP=1 \
        -e DISABLE_STRACE=1 \
        -e "LOG_LEVEL=$LOG_LEVEL" \
        -e RUST_BACKTRACE=0 \
        -e "LOG_DIR=$LOG_DIR" \
        -e "TEST_ARGS=$test_args" \
        -v "$(pwd):/app" \
        -v "$DOCKER_SCRIPT:/run-docker-tests.sh" \
        --workdir /app \
        letmein-test \
        /run-docker-tests.sh
        
    # Nettoyage du script temporaire
    rm -f "$DOCKER_SCRIPT"
    
    TEST_EXIT_CODE=$?
    
    # Display test results
    if [ $TEST_EXIT_CODE -eq 0 ]; then
        echo -e "${GREEN}=== DOCKER TESTS SUCCEEDED (exit code: $TEST_EXIT_CODE) ===${NC}"
    else
        echo -e "${RED}=== DOCKER TESTS FAILED (exit code: $TEST_EXIT_CODE) ===${NC}"
        echo -e "${YELLOW}You can debug further with: $0 --debug${NC}"
    fi
    
    # Display debug logs information
    display_logs_info
    
    return $TEST_EXIT_CODE
}

# Function to run interactive debug mode in Docker
run_debug_mode() {
    echo -e "${GREEN}=== STARTING INTERACTIVE DEBUG SHELL IN DOCKER ===${NC}"
    echo -e "${YELLOW}Using real nftables for debugging${NC}"
    
    docker build -t letmein-test -f Dockerfile.test .
    
    echo -e "${BLUE}Starting interactive Docker container for debugging...${NC}"
    echo -e "${YELLOW}Use './tests/run-tests.sh <test>' to run specific tests${NC}"
    echo -e "${YELLOW}Use './test.sh --local <test>' to run the local test flow${NC}"
    
    docker run --rm -it \
        --privileged \
        --cap-add=NET_ADMIN \
        --cap-add=SYS_ADMIN \
        --dns 8.8.8.8 \
        --dns 1.1.1.1 \
        --security-opt seccomp=unconfined \
        -e LETMEIN_DISABLE_SECCOMP=1 \
        -e DISABLE_STRACE=1 \
        -e "LOG_LEVEL=$LOG_LEVEL" \
        -e RUST_BACKTRACE=1 \
        -v "$(pwd):/app" \
        --workdir /app \
        letmein-test \
        /bin/sh
}

# Fonction pour vérifier la validité des tests spécifiés
validate_tests() {
    local valid_tests=("knock" "close" "gen-key")
    local unknown_tests=()
    
    for test in "$@"; do
        # Ignorer les chemins de scripts Docker ou les commandes shell
        if [[ "$test" == "/"* || "$test" == "sh" ]]; then
            continue
        fi
        
        local is_valid=0
        for valid_test in "${valid_tests[@]}"; do
            if [ "$test" = "$valid_test" ]; then
                is_valid=1
                break
            fi
        done
        
        if [ $is_valid -eq 0 ]; then
            unknown_tests+=("$test")
        fi
    done
    
    # Afficher un avertissement pour les tests inconnus
    for unknown in "${unknown_tests[@]}"; do
        echo -e "${YELLOW}=== WARNING: Test inconnu: $unknown${NC}"
    done
}

# --- MAIN SCRIPT LOGIC ---

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h)
            show_help
            ;;
        --local)
            MODE="local"
            shift
            ;;
        --docker)
            MODE="docker"
            shift
            ;;
        --debug)
            MODE="debug"
            shift
            ;;
        --with-gen-key)
            WITH_GEN_KEY=1
            shift
            ;;
        --capture-interval)
            CAPTURE_INTERVAL="$2"
            shift 2
            ;;
        --verbose)
            LOG_LEVEL="verbose"
            shift
            ;;
        --minimal)
            LOG_LEVEL="minimal"
            shift
            ;;
        *)
            # Collecte des tests à exécuter
            RUN_TESTS+=("$1")
            shift
            ;;
    esac
done

# Afficher la configuration
echo "Mode: $MODE testing"
if [ "$LOG_LEVEL" != "normal" ]; then
    echo "Log level: ${LOG_LEVEL^}"
fi

# Afficher les tests à exécuter
for test in "${RUN_TESTS[@]}"; do
    echo "Adding test: $test"
done

# Valider les tests spécifiés
if [ ${#RUN_TESTS[@]} -gt 0 ]; then
    validate_tests "${RUN_TESTS[@]}"
fi

# Mode debug ne nécessite pas de validation des tests
if [ "$MODE" = "debug" ]; then
    run_debug_mode
    exit $?
fi

# Mode Docker ou local
if [ "$MODE" = "docker" ]; then
    run_docker_tests
    exit $?
else
    run_local_tests
    exit $?
fi
