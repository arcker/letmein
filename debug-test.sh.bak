#!/bin/bash
# Script de débogage des tests avec logs nftables détaillés

# Couleurs pour l'affichage
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Répertoire des logs
LOG_DIR="$(pwd)/nft-logs"

# Options par défaut
MOCK_NFTABLES="1" # Par défaut, on utilise le stub nftables
DEBUG_INTERVAL="5" # Intervalle par défaut entre les captures d'état
RUN_TEST="knock close" # Par défaut, exécuter les tests knock et close

# Préparation de l'environnement
export LETMEIN_DISABLE_SECCOMP=1
export DISABLE_STRACE=1

# Fonction d'aide
usage() {
    echo -e "${YELLOW}Usage: $0 [OPTIONS]${NC}"
    echo -e "Options:"
    echo -e "  --real           Utiliser de vraies règles nftables au lieu du stub"
    echo -e "  --interval N     Définir l'intervalle entre les captures d'état (en secondes, défaut: 5)"
    echo -e "  --test TESTS     Tests à exécuter (knock, close, ou gen-key, défaut: knock close)"
    echo -e "  --help           Afficher ce message d'aide"
    exit 0
}

# Traitement des options de ligne de commande
while [ $# -gt 0 ]; do
    case "$1" in
        --real)
            MOCK_NFTABLES="0"
            echo -e "${YELLOW}Mode réel activé (sans MOCK_NFTABLES)${NC}"
            ;;
        --interval)
            shift
            DEBUG_INTERVAL="$1"
            echo -e "${YELLOW}Intervalle de débogage: $DEBUG_INTERVAL secondes${NC}"
            ;;
        --test)
            shift
            RUN_TEST="$1"
            echo -e "${YELLOW}Tests à exécuter: $RUN_TEST${NC}"
            ;;
        --help)
            usage
            ;;
        *)
            echo -e "${RED}Option inconnue: $1${NC}"
            usage
            ;;
    esac
    shift
}

# Créer répertoire de logs
mkdir -p "$LOG_DIR"
echo -e "${BLUE}Les logs seront sauvegardés dans $LOG_DIR${NC}"

# Fonction pour capturer l'état des règles nftables
capture_nft_state() {
    local suffix="$1"
    local timestamp=$(date +"%Y%m%d-%H%M%S")
    local logfile="$LOG_DIR/nft-state-$suffix-$timestamp.log"
    
    echo -e "${BLUE}Capturing nftables state: $suffix${NC}"
    
    echo "========================================================" > "$logfile"
    echo "=== CAPTURE NFTABLES STATE: $suffix $(date) ===" >> "$logfile"
    echo "========================================================" >> "$logfile"
    
    echo -e "\n=== Variables d'environnement ===" >> "$logfile"
    echo "MOCK_NFTABLES=$MOCK_NFTABLES" >> "$logfile"
    echo "LETMEIN_DISABLE_SECCOMP=$LETMEIN_DISABLE_SECCOMP" >> "$logfile"
    
    echo -e "\n=== Commande 'nft list ruleset' (format texte) ===" >> "$logfile"
    nft list ruleset 2>&1 >> "$logfile"
    echo "Exit code: $?" >> "$logfile"
    
    echo -e "\n=== Commande 'nft -j list ruleset' (format JSON) ===" >> "$logfile"
    nft -j list ruleset 2>&1 >> "$logfile"
    echo "Exit code: $?" >> "$logfile"
    
    echo -e "\n=== Tables nftables existantes ===" >> "$logfile"
    nft list tables 2>&1 >> "$logfile"
    
    echo -e "\n=== Chaînes nftables existantes ===" >> "$logfile"
    nft list chains 2>&1 >> "$logfile"
    
    echo -e "\n=== Recherche des règles pour le port 42 ===" >> "$logfile"
    nft list ruleset | grep -i "42" 2>&1 >> "$logfile" || echo "Aucune règle trouvée pour le port 42" >> "$logfile"
    
    echo -e "\n=== Recherche des règles pour les adresses ::1 et 127.0.0.1 ===" >> "$logfile"
    nft list ruleset | grep -E "::1|127.0.0.1" 2>&1 >> "$logfile" || echo "Aucune règle trouvée pour les adresses ::1 ou 127.0.0.1" >> "$logfile"
    
    echo -e "${GREEN}Capture saved to: $logfile${NC}"
    return 0
}

# Fonction pour exécuter un processus en arrière-plan qui capture périodiquement l'état
start_periodic_capture() {
    echo -e "${BLUE}Starting periodic nftables state capture every $DEBUG_INTERVAL seconds${NC}"
    
    # Générer un identifiant unique pour cette session de débogage
    SESSION_ID=$(date +"%Y%m%d-%H%M%S")
    
    # Créer un script temporaire pour la capture périodique
    TEMP_SCRIPT="$LOG_DIR/capture-$SESSION_ID.sh"
    
    cat > "$TEMP_SCRIPT" << EOF
#!/bin/bash
count=0
while true; do
    count=\$((count+1))
    echo "Periodic capture #\$count at \$(date)" >> "$LOG_DIR/periodic-$SESSION_ID.log"
    
    echo "========================================================" >> "$LOG_DIR/nft-periodic-\$count-$SESSION_ID.log"
    echo "=== PERIODIC CAPTURE #\$count: \$(date) ===" >> "$LOG_DIR/nft-periodic-\$count-$SESSION_ID.log"
    echo "========================================================" >> "$LOG_DIR/nft-periodic-\$count-$SESSION_ID.log"
    
    echo -e "\\n=== Commande 'nft list ruleset' ===" >> "$LOG_DIR/nft-periodic-\$count-$SESSION_ID.log"
    nft list ruleset 2>&1 >> "$LOG_DIR/nft-periodic-\$count-$SESSION_ID.log"
    
    echo -e "\\n=== Recherche des règles pour le port 42 ===" >> "$LOG_DIR/nft-periodic-\$count-$SESSION_ID.log"
    nft list ruleset | grep -i "42" 2>&1 >> "$LOG_DIR/nft-periodic-\$count-$SESSION_ID.log" || echo "Aucune règle trouvée pour le port 42" >> "$LOG_DIR/nft-periodic-\$count-$SESSION_ID.log"
    
    sleep $DEBUG_INTERVAL
done
EOF
    
    chmod +x "$TEMP_SCRIPT"
    "$TEMP_SCRIPT" &
    CAPTURE_PID=$!
    echo -e "${GREEN}Periodic capture started with PID: $CAPTURE_PID${NC}"
    echo $CAPTURE_PID > "$LOG_DIR/capture-pid-$SESSION_ID.txt"
}

# Fonction pour arrêter la capture périodique
stop_periodic_capture() {
    if [ -f "$LOG_DIR/capture-pid-$SESSION_ID.txt" ]; then
        CAPTURE_PID=$(cat "$LOG_DIR/capture-pid-$SESSION_ID.txt")
        echo -e "${BLUE}Stopping periodic capture (PID: $CAPTURE_PID)${NC}"
        kill $CAPTURE_PID 2>/dev/null || echo -e "${YELLOW}Unable to kill capture process${NC}"
        rm "$LOG_DIR/capture-pid-$SESSION_ID.txt"
    else
        echo -e "${YELLOW}No active periodic capture found for this session${NC}"
    fi
}
export STRACE_CMD=""
export STRACE_DISABLED=1

# Préparer l'environnement pour les tests
if [ "$MOCK_NFTABLES" = "1" ]; then
    export MOCK_NFTABLES=1
    echo -e "${YELLOW}Running tests with nftables stub (MOCK_NFTABLES=1)...${NC}"
else
    unset MOCK_NFTABLES
    echo -e "${YELLOW}Running tests with real nftables...${NC}"
fi

# Section principale d'exécution
echo -e "${GREEN}=== DÉMARRAGE DU DÉBOGAGE NFTABLES ===${NC}"

# Capture de l'état initial
capture_nft_state "initial"

# Démarrer la capture périodique
start_periodic_capture

# Compiler le projet si nécessaire
echo -e "${YELLOW}Compilation du projet...${NC}"
cargo build

# Exécuter les tests avec le script run-tests.sh
echo -e "${GREEN}=== EXÉCUTION DES TESTS ($RUN_TEST) ===${NC}"

# Capture de l'état avant les tests
capture_nft_state "avant-tests"

# Exécuter les tests spécifiés
echo -e "${YELLOW}Exécution des tests: $RUN_TEST${NC}"
./tests/run-tests.sh $RUN_TEST
TEST_EXIT_CODE=$?

# Capture de l'état après les tests
capture_nft_state "apres-tests"

# Arrêter la capture périodique
stop_periodic_capture

# Afficher le résultat des tests
if [ $TEST_EXIT_CODE -eq 0 ]; then
    echo -e "${GREEN}=== TESTS RÉUSSIS (code de sortie: $TEST_EXIT_CODE) ===${NC}"
else
    echo -e "${RED}=== TESTS ÉCHOUÉS (code de sortie: $TEST_EXIT_CODE) ===${NC}"
fi

# Afficher le chemin des logs
echo -e "${GREEN}=== DÉBOGAGE TERMINÉ ===${NC}"
echo -e "${BLUE}Les logs de débogage sont disponibles dans: $LOG_DIR${NC}"
echo -e "${BLUE}Fichiers de logs importants:${NC}"
ls -la "$LOG_DIR" | grep -E "initial|avant-tests|apres-tests" | awk '{print $9}' | while read file; do
    echo -e "${YELLOW}- $LOG_DIR/$file${NC}"
done

# Suggérer des commandes utiles
echo -e "\n${GREEN}Commandes utiles:${NC}"
echo -e "${YELLOW}- Pour voir la sortie des tests: less -R $LOG_DIR/nft-state-apres-tests-*.log${NC}"
echo -e "${YELLOW}- Pour comparer avant/après: diff $LOG_DIR/nft-state-avant-tests-*.log $LOG_DIR/nft-state-apres-tests-*.log${NC}"

# Sortir avec le code de sortie des tests
exit $TEST_EXIT_CODE
mkdir -p "$RUNDIR" "$LOGDIR"

echo "=== Configuration ==="
CONFIG="$BASEDIR/tests/conf/tcp.conf"
echo "Répertoire temporaire: $TMPDIR"
echo "Fichiers de log: $LOGDIR"

echo "=== Démarrage des services ==="
echo "Démarrage de letmeinfwd..."
"$TARGETDIR/letmeinfwd" \
    --test-mode \
    --no-systemd \
    --rundir "$RUNDIR" \
    --seccomp off \
    --config "$CONFIG" > "$LOGDIR/letmeinfwd.out" 2> "$LOGDIR/letmeinfwd.err" &
LETMEINFWD_PID=$!
echo "PID letmeinfwd: $LETMEINFWD_PID"

echo "Démarrage de letmeind..."
"$TARGETDIR/letmeind" \
    --no-systemd \
    --rundir "$RUNDIR" \
    --seccomp off \
    --config "$CONFIG" > "$LOGDIR/letmeind.out" 2> "$LOGDIR/letmeind.err" &
LETMEIND_PID=$!
echo "PID letmeind: $LETMEIND_PID"

# Attendre que les services soient prêts
sleep 2

echo "=== Test de la commande knock ==="
"$TARGETDIR/letmein" \
    --verbose \
    --seccomp off \
    --config "$CONFIG" \
    knock \
    --user 12345678 \
    localhost 42 > "$LOGDIR/knock.out" 2> "$LOGDIR/knock.err"

KNOCK_STATUS=$?
echo "Statut de la commande knock: $KNOCK_STATUS"

# Afficher les logs en cas d'échec
if [ $KNOCK_STATUS -ne 0 ]; then
    echo "=== Contenu des logs d'erreur ==="
    echo "--- letmeinfwd.err ---"
    cat "$LOGDIR/letmeinfwd.err"
    echo "--- letmeind.err ---"
    cat "$LOGDIR/letmeind.err"
    echo "--- knock.err ---"
    cat "$LOGDIR/knock.err"
fi

# Nettoyage
echo "=== Nettoyage ==="
kill $LETMEINFWD_PID
kill $LETMEIND_PID
wait

echo "Logs disponibles dans $LOGDIR"

exit $KNOCK_STATUS
